{
  "hash": "f82dcc0d55d6cd6b0f392479fa69b03e",
  "result": {
    "engine": "knitr",
    "markdown": "\n#  Project workflows {#sec-workflow}\n\n\n\n\n\n\n\n\n\n\n\nIn RStudio, a project is a way to organize your work within the IDE. It's a fundamental concept designed to enhance your workflow by providing a structured and efficient means of managing your R-related tasks and files. Here's why R projects are useful:\n\n**1. Organized File Structure:** R projects encourage you to maintain a well-organized file structure for your work. Instead of having scattered R scripts, data files, and figures, you create a dedicated folder for each project. This folder typically contains all project-related materials, including data, code, figures, notes, and any other relevant files.\n\n**2. Working Directory Management:** When you open an R project in RStudio, it automatically sets the working directory to the project's folder. This ensures that all file paths are relative to the project's location. This working directory intentionality eliminates the need for setting working directories manually or using absolute paths in your code.\n\n**3. Portability and Collaboration:** R projects make your work more portable and collaborative. Since all paths are relative to the project folder, the project can be easily shared with others. It ensures that the code works consistently across different computers and for other users, promoting collaboration and reproducibility.\n\n**4. RStudio Integration:** RStudio integrates project management seamlessly. You can designate a folder as an R project, and RStudio leaves a `.Rproj` file in that folder to store project-specific settings. When you double-click on this file, it opens a fresh instance of RStudio with the project's working directory and file browser pointed at the project folder.\n\n**5. Efficient Workflow:** RStudio provides various menu options and keyboard shortcuts for managing projects. This includes the ability to open existing projects, switch between projects, and even launch multiple instances of RStudio for different projects.\n\nIn essence, R projects help you maintain a clean and organized workspace, improve collaboration, and ensure that your work remains reproducible and transferable across different environments and over time. It's a best practice for data scientists and analysts working with R, as it fosters the disciplined use of relative file paths and working directories, which is crucial for the reliability and scalability of your R projects.\n\n\n## Setting up a new project\n\nYou should start a new R project when you begin working on a distinct task, research project, or analysis. This ensures that your work is well-organized, and it's especially beneficial when you need to collaborate, share, or revisit the project later.\n\nTo create and open an R project in RStudio:\n\n1. Go to \"File\" in the RStudio menu.\n\n2. Select \"New Project...\"\n\n3. Choose a project type or create a new directory for the project.\n\n4. Click \"Create Project.\"\n\nThe new project will be created with a .Rproj file. You can open it by double-clicking on this file or by using the \"File\" menu in RStudio.\n\nThis will set up a dedicated workspace for your project, ensuring that the working directory and file paths are appropriately managed.\n\n::: {.callout-tip}\n## Avoiding setwd() and Promoting Safe File Paths:\n\nTo maintain a clean and efficient workflow in R, it's advisable to avoid using `setwd()` at the beginning of each script. This practice promotes the use of safe file paths and is particularly important for projects with multiple collaborators or when working across different computers.\n:::\n\n### Absolute vs. Relative Paths:\n\nWhile absolute file paths provide an explicit way to locate resources, they have significant drawbacks, such as incompatibility and reduced reproducibility. Relative file paths, on the other hand, are relative to the current working directory, making them shorter, more portable, and more reproducible.\n\nAn **Absolute file path** is a path that contains the entire path to a file or directory starting from your Home directory and ending at the file or directory you wish to access e.g.\n\n```\n/home/your-username/project/data/penguins_raw.csv\n```\n\n- If you share files, another user won’t have the same directory structure as you, so they will need to recreate the file paths\n\n- If you alter your directory structure, you’ll need to rewrite the paths\n\n- An absolute file path will likely be longer than a relative path, more of the backslashes will need to be edited, so there is more scope for error.\n\nA **Relative filepath** is the path that is relative to the working directory location on your computer.\n\nWhen you use RStudio Projects, wherever the `.Rproj` file is located is set to the working directory. This means that if the `.Rproj` file is located in your project folder then the relative path to your data is:\n\n```\ndata/penguins_raw.csv\n```\n\nThis filepath is shorter and it means you could share your project with someone else and the script would run without any editing.\n\n### Organizing Projects:\n\nA key aspect of this workflow is organizing each logical project into a separate folder on your computer. This ensures that files and scripts are well-structured, making it easier to manage your work.\n\n### The `here` Package:\n\nTo further enhance this organization and ensure that file paths are independent of specific working directories, the here package comes into play. The `here::here()` function provided by this package builds file paths relative to the top-level directory of your project.\n\n```\nmy_project.RProj/\n    |- data/\n    |   |- raw/\n    |       |- penguins_raw.csv\n    |   |- processed/\n    |- scripts/\n    |   |- analysis.R\n    |- results/\n\n\n```\n\nIn the above project example you have raw data files in the data/raw directory, scripts in the scripts directory, and you want to save processed data in the data/processed directory.\n\nTo access this data using a relative filepath we need:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nraw_data <- read.csv(\"data/raw/penguins_raw.csv\")\n```\n:::\n\n\n\n\nTo access this data with `here` we provide the directories and desired file, and `here()` builds the required filepath starting at the top level of our project each time\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(here)\n\nraw_data <- read.csv(here(\"data\", \"raw\", \"penguins.csv\"))\n```\n:::\n\n\n\n\n::: {.callout-tip}\n#### here and Rmarkdown\n\nOne quirk of working in a `.Rmd` Rmarkdown file is that when you \"knit\" all code is compiled with the working directory as the folder that .Rmd file lives in, but if you are working in a script `.R` or in a live session then the default working directory is the top level of the project file. This frustrating and confusing process can lead to errors when attempting to compile documents. \n\n**BUT** if you use the `here` package then this default behaviour is overridden. The working directory when knitting will be the top-level .Rproj location again!\n:::\n\n\n## Blank slates\n\nWhen working on data analysis and coding projects in R, it's crucial to ensure that your analysis remains clean, reproducible, and free from hidden dependencies. \n\nHidden dependencies are elements in your R session that might not be immediately apparent but can significantly impact the reliability and predictability of your work.\n\nFor example many data analysis scripts start with the command `rm(list = ls())`. While this command clears user-created objects from the workspace, it leaves hidden dependencies as it does not reset the R session, and can cause issues such as: \n\n- **Hidden Dependencies:** Users might unintentionally rely on packages or settings applied in the current session.\n\n- **Incomplete Reset:** Package attachments made with `library()` persist, and customized options remain set.\n\n- **Working Directory:** The working directory is not affected, potentially causing path-related problems in future scripts.\n\n### Restart R sessions\n\nRestarting R sessions and using scripts as your history is a best practice for maintaining a clean, reproducible, and efficient workflow. It addresses the limitations of `rm(list = ls())` by ensuring a complete reset and minimizing hidden dependencies, enhancing code organization, and ensuring your analysis remains robust and predictable across sessions and when shared with others.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/rstudio-workspace.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n# Basic Import/Export\n\nWhen loading data into R, the choice of method matters, especially for tabular data like CSV files. There are two different approaches: \n\n- base R's `read.csv()`\n\n- the `readr` package with functions like `readr::read_csv()`\n\nThe performance gains of `readr` become significant as data size grows, especially for datasets with many rows. For files larger than 100 MB, `read_csv()` is about five times faster than `read.csv()`.\n\nKeep in mind that  `readr` is a separate package (part of tidyverse), requiring installation and loading.\n\n> readr functions\n\n| Function         | Description                                          |\n|------------------|------------------------------------------------------|\n| `read_csv()`     | CSV file format                                      |\n| `read_tsv()`     | TSV (Tab-Separated Values) file format               |\n| `read_delim()`   | User-specified delimited files                       |\n\n\n\n## Export\n\nEach of these packages and functions has the inverse \"write\" function to produce files in a variety of formats from R objects.\n\n\n| Function         | Description                                          |\n|------------------|------------------------------------------------------|\n| `write_csv()`     | CSV file format                                      |\n| `write_tsv()`     | TSV (Tab-Separated Values) file format               |\n| `write_delim()`   | User-specified delimited files                       |\n\n## Scripts\n\nTo ensure clarity and understanding, begin your script with a brief description of its purpose. This description will serve as a reference point for anyone who accesses your script. Even if you make updates later on, having this initial description will help maintain clarity and context, preventing confusion when revisiting the code in the future.\n\n## Organised scripts\n\nLoad all necessary packages at the beginning of your script.\nIt's common to start with basic packages and then add more specialized libraries as your analysis progresses. However, it's crucial to load all required packages at the beginning of your script. This practice ensures that when you or someone else needs to run the script again, all necessary libraries are readily available, preventing issues in the middle of execution due to unrecognized functions. Small coding details matter.\n\nName your code sections and use them for quick navigation.\nAs your code grows, it may become extensive and challenging to manage. To keep it organized, divide your code into sections, each with a specific name, which can be folded or unfolded for easy navigation. You can also use the 'drop-up' menu at the bottom of the script screen to move between sections.\n\nTo create a new code section, insert \"####\" or \"----\" at the end of a comment that marks the beginning of a new section.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/organised script.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\nI understand, we all have good intentions, but we often neglect the task of thoroughly commenting our code. I've made that promise to myself many times, but even now, I struggle to do it consistently. Why, you ask? Here are a few reasons:\n\n1. I often tell myself that the analysis itself is more crucial.\n2. I believe I understand my own code.\n3. I usually don't have immediate collaborators who need to use my code.\n\nHowever, these arguments are somewhat shortsighted. The reality is that:\n\n- The most valuable and relevant analysis loses its value if neither you nor others can understand it. (More on this below)\n- While you may know what you're doing at the moment, it won't feel the same way in a month or two when you've moved on to another project, and someone innocently asks you about how you defined a critical variable. Our memory is unreliable. It's important not to rely on it for every piece of code you produce.\n- Even if you don't have active collaborators at the time of your analysis, someone will eventually need to use your code. You won't be in the same position forever. You're creating a legacy that, someday, someone will rely on, no matter how distant that day may seem right now.\n\nSo, what makes code good and reproducible?\n\n1. Thoughtful and clear comments.\n2. Code that is logical and efficient.\n3. Code that has been appropriately timed and tested.\n\n## Use style guides\n\nConsider using a style guide, such as the [tidyverse style guide](https://style.tidyverse.org/){target=\"_blank\"}, is a beneficial practice for several reasons:\n\nConsistency: A style guide enforces consistent code formatting and naming conventions throughout your project. This consistency improves code readability and makes it easier for you and others to understand the code. When you have multiple people working on a project, a shared style guide ensures that everyone's code looks similar, reducing confusion and errors.\n\nReadability: Following a style guide leads to more readable code. Code is often read more frequently than it is written, so making it easy to understand is crucial. The tidyverse style guide, for example, emphasizes clear and self-explanatory code, improving comprehension for both current and future users. Good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread\n\nCollaboration: When working with a team, adhering to a common style guide makes it easier to collaborate. It reduces the friction associated with different team members using varying coding styles and preferences. This streamlines code reviews and simplifies the process of maintaining and extending the codebase.\n\nError Reduction: A style guide can help identify and prevent common coding errors. It promotes best practices and can include guidelines for avoiding pitfalls and potential issues. This reduces the likelihood of bugs and enhances the overall quality of the code.\n\n## Separate your scripts\n\nSeparating your analysis into distinct scripts for different steps is a sound practice in data analysis. Each script can focus on a specific task or step, making your work more organized and understandable.\n\nYou can use the `source()` function in R to run previous dependencies, ensuring that you can reproduce your work easily. Additionally, for computationally intensive processes or when dealing with large datasets, you can save and load intermediate results in RDS format. This approach not only conserves memory but also saves time when re-running your analysis.\n\n```\nproject_folder/\n│\n├── data/\n│   ├── data.csv\n│   ├── processed_data.rds\n│\n├── scripts/\n│   ├── data_preparation.R\n│   ├── data_analysis.R\n│   ├── visualization.R\n│   ├── helper_functions.R\n│\n├── output/\n│   ├── result.csv\n│\n├── README.md\n│\n├── project.Rproj\n\n```\n\n## Activity\n\nUsing the [Tidyverse style guide](https://style.tidyverse.org/index.html){target=\"_blank\"} for help, how could you improve the layout and readability of this script?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Install and load necessary packages\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(palmerpenguins)\n\npenguins_clean <- janitor::clean_names(penguins_raw)\n\n\n## Data is selected by species, island, culmen length and depth and flipper, then NAs are dropped and a new column is made of length/depth and the mean is summaries for flipper length and length/depth ratio\npenguins_clean |> select(species, island, culmen_length_mm, culmen_depth_mm, flipper_length_mm)  |> drop_na(culmen_length_mm, culmen_depth_mm, flipper_length_mm) |> mutate(culmen_ratio = culmen_length_mm / culmen_depth_mm) |> group_by(species, island) |> summarise(mean_flipper_length = mean(flipper_length_mm), mean_culmen_ratio = mean(culmen_ratio)) |> arrange(species, island) -> penguins_culmen_ratio\n\n## View summary table\nprint(penguins_culmen_ratio)\n\n\n### Data visualization \npenguins_clean |>\n  ggplot(aes(x = culmen_length_mm, y = culmen_depth_mm, color = species)) +\n          geom_point() +\n                labs(x = \"Culmen Length (mm)\", y = \"Culmen Depth (mm)\") +\n                      theme_minimal()\n```\n:::\n\n\n\n\n\n\n<div class='webex-solution'><button>Check your script</button>\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Packages ----\n# Install and load necessary packages\nlibrary(tidyverse)\nlibrary(janitor)\n# Loads the penguins dataset\nlibrary(palmerpenguins)\n\n\n# Clean the data ----\npenguins_raw <- janitor::clean_names(penguins_raw)\n\n# Analysis----\n# Data exploration and manipulation to make culmen ratio\npenguins_culmen_ratio <- penguins_raw |> \n  select(species, island, \n         culmen_length_mm, \n         culmen_depth_mm, \n         flipper_length_mm)  |> \n  drop_na(culmen_length_mm, \n          culmen_depth_mm, \n          flipper_length_mm) |> \n  mutate(culmen_ratio = culmen_length_mm / culmen_depth_mm) |>\n  group_by(species, island) |>\n  summarise(mean_flipper_length = mean(flipper_length_mm), \n            mean_culmen_ratio = mean(culmen_ratio)) |>\n  arrange(species, island)\n\n# View summary table\nprint(penguins_culmen_ratio)\n\n# Plots----\n# Data visualization using ggplot2\npenguins_clean |>\n  ggplot(aes(x = culmen_length_mm, \n             y = culmen_depth_mm, \n             color = species)) +\n  geom_point() +\n  labs(x = \"Culmen Length (mm)\", \n       y = \"Culmen Depth (mm)\") +\n  theme_minimal()\n```\n:::\n\n\n\n\n\n</div>\n\n\n## Naming things\n\nSo as we are reading things into and out of our environment we come to filenames. \n\nSo, what makes a good file name? Well, there are a few key principles to keep in mind:\n\n**1. Machine Readable:** Your file names should be machine-readable, meaning they work well with regular expressions and globbing. This allows you to search for files using keywords, with the help of regex and the stringr package. To achieve this, avoid spaces, punctuation, accented characters, and case sensitivity. This makes searching for files and filtering lists based on names easier in the future.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/jenny1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n\n**2. Easy to Compute On:** File names should be structured consistently, with each part of the name serving a distinct purpose and separated by delimiters. This structure makes it easy to extract information from file names, such as splitting them into meaningful components.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/jenny2.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n**3. Human Readable:** A good file name should be human-readable. It should provide a clear indication of what the file contains, just by looking at its name. It's important that even someone unfamiliar with your work can easily understand the file's content.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/jenny3.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n**4. Compatible with Default Ordering:** Your computer will automatically sort your files, whether you like it or not. To ensure files are sorted sensibly, consider the following:\n\n- Put something numeric at the beginning of the file name. If the order of sourcing files matters, state when the file was created. If not, indicate the logical order of the files.\n\n- Use the YYYY-MM-DD format for dates (it's an ISO 8601 standard). This format helps maintain chronological order, even for Americans.\n\n- Left-pad numbers with zeroes to avoid incorrect sorting (e.g., 01 not 1).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/jenny4.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\nTaking these simple but effective steps can significantly enhance your workflow and help your colleagues as well. Remember, good file names are a small change that can make a big difference in your productivity.\n\n\n## Reading\n\n\n\n- [Using the here package](https://github.com/jennybc/here_here)\n\n\n- [Data Organisation in Spreadsheets](https://www.tandfonline.com/doi/full/10.1080/00031305.2017.1375989)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}